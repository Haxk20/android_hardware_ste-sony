From f32f01897c6e82aa0724d5929c8ab45efbbb4733 Mon Sep 17 00:00:00 2001
From: Shilin Victor <chrono.monochrome@gmail.com>
Date: Sun, 30 Apr 2017 12:58:53 +0300
Subject: [PATCH] HWComposer: Upgrade to v1.0

credits to @3liteking148
---
 display/libhwcomposer/Android.mk   |   1 +
 display/libhwcomposer/hwcomposer.c | 174 ++++----
 display/libhwcomposer/hwcomposer.h | 797 +++++++++++++++++++++++++++++--------
 3 files changed, 711 insertions(+), 261 deletions(-)

diff --git a/display/libhwcomposer/Android.mk b/display/libhwcomposer/Android.mk
index 2d69ee80..bcb8b9c6 100644
--- a/display/libhwcomposer/Android.mk
+++ b/display/libhwcomposer/Android.mk
@@ -26,5 +26,6 @@ LOCAL_SHARED_LIBRARIES := liblog libcutils libEGL libGLESv1_CM libhardware
 LOCAL_SRC_FILES := hwcomposer.c sw_vsync.c
 #vsync_monitor.c
 LOCAL_MODULE := hwcomposer.$(TARGET_BOARD_PLATFORM)
+LOCAL_CLANG := false
 LOCAL_MODULE_TAGS := optional
 include $(BUILD_SHARED_LIBRARY)
diff --git a/display/libhwcomposer/hwcomposer.c b/display/libhwcomposer/hwcomposer.c
index 436c6695..99e149f3 100644
--- a/display/libhwcomposer/hwcomposer.c
+++ b/display/libhwcomposer/hwcomposer.c
@@ -4,11 +4,14 @@
  */
 
 #define LOG_TAG "STE-HWComposer"
+#define HWC_REMOVE_DEPRECATED_VERSIONS 1
 
 #include <hardware/hardware.h>
-#include "hwcomposer.h"
+#include <hardware/hwcomposer.h>
+#include <hardware/hwcomposer_defs.h>
 #include <cutils/log.h>
 #include <stdbool.h>
+#include <stdlib.h>
 #include <sys/types.h>
 #include <sys/stat.h>
 #include <sys/ioctl.h>
@@ -30,25 +33,13 @@
 #include <grp.h>
 #include "vsync_monitor.h"
 
-/* Use the STE version if available, otherwise fall back to
- * the corresponding vanilla version.
- * Note: the STE version is normally only unavailable
- * during the bring-up period of an Android upgrade.
- */
-#ifdef HWC_DEVICE_API_VERSION_0_3_STE
-#define STE_HWC_DEVICE_API_CURRENT HWC_DEVICE_API_VERSION_0_3_STE
-#else
-#define STE_HWC_DEVICE_API_CURRENT HWC_DEVICE_API_VERSION_0_3
-#endif
-
 #define DEBUG_STE_HWCOMPOSER 0
 #define DEBUG_STE_HWCOMPOSER_LAYER_DUMP 0
 #define DEBUG_STE_HWCOMPOSER_ALLOC 0
 
 #define HWMEM_PATH ("/dev/" HWMEM_DEFAULT_DEVICE_NAME)
 #define COMPDEV_PATH "/dev/comp0"
-
-#ifdef ENABLE_HDMI
+#if 0
 #define HDMID_SOCKET_LISTEN_PATH "/dev/socket/hdmid"
 #endif
 
@@ -61,8 +52,19 @@
 /* Max number of layers that can be cached. */
 #define CACHED_LAYERS_SIZE 16
 
+/*
+ * names for setParameter()
+ */
+enum {
+    /* Specifies the UI orientation */
+    HWC_UI_ORIENTATION = 0x00000000,
+    /* Specifies if hardware rotation is used */
+    HWC_HARDWARE_ROTATION = 0x00000001,
+    /* Set the hdmi plug status */
+    HWC_HDMI_PLUGGED = 0x00000002,
+};
 
-#ifdef ENABLE_HDMI
+#if 0
 typedef struct hwc_hdmi_setting {
     bool                 hdmi_plugged;
     bool                 resolutionchanged;
@@ -73,23 +75,20 @@ typedef struct hwc_hdmi_setting {
 
 static int hwcomposer_device_open(const struct hw_module_t *module,
         const char *name, struct hw_device_t **device);
-
-static int hwcomposer_setparameter(struct hwc_composer_device *dev,
+static int hwcomposer_setparameter(struct hwc_composer_device_1 *dev,
                 int param, int value);
-
-static int hwcomposer_eventControl(struct hwc_composer_device* dev,
-                int event, int enabled);
+static int hwcomposer_eventControl(struct hwc_composer_device_1* dev, int event, int dpy, int enabled);
 
 static struct hw_module_methods_t hwcomposer_module_methods = {
     .open = hwcomposer_device_open,
 };
 
-static struct hwc_methods hwcomposer_methods = {
-    .eventControl = hwcomposer_eventControl,
-#ifdef HWC_DEVICE_API_VERSION_0_3_STE
-    .setParameter = hwcomposer_setparameter,
-#endif /* HWC_DEVICE_API_VERSION_0_3_STE */
-};
+
+static int hwcomposer_blank(struct hwc_composer_device_1 *dev,
+        int disp, int blank)
+{
+        return 0;
+}
 
 struct hwc_module HAL_MODULE_INFO_SYM = {
     .common = {
@@ -115,7 +114,7 @@ struct worker_context {
     int hwmem;
     int compdev;
     const struct gralloc_module_t *gralloc;
-    hwc_layer_list_t* work_list;
+    hwc_display_contents_1_t* work_list;
     struct hwc_rect* frame_rect;
     uint32_t compdev_layer_count;
     uint32_t compdev_bypass_count;
@@ -126,7 +125,7 @@ struct worker_context {
 };
 
 struct hwcomposer_context {
-    struct hwc_composer_device dev;
+    struct hwc_composer_device_1 dev;
     pthread_mutex_t hwc_mutex;
     int hwmem;
     int compdev;
@@ -163,7 +162,7 @@ static int worker_init(struct hwcomposer_context *ctx,
                         const struct gralloc_module_t *gralloc);
 static int worker_destroy(struct hwcomposer_context *ctx);
 static int worker_signal_update(struct hwcomposer_context *ctx,
-                                hwc_layer_list_t* work_list,
+                                hwc_display_contents_1_t* work_list,
                                 uint32_t compdev_layer_count,
                                 uint32_t compdev_bypass_count,
                                 struct hwc_rect* frame_rect);
@@ -770,7 +769,7 @@ int init_layer_cache_locked(struct hwcomposer_context *ctx)
     return 0;
 }
 
-void populate_cached_layer_locked(struct hwcomposer_context *ctx, hwc_layer_list_t* list)
+void populate_cached_layer_locked(struct hwcomposer_context *ctx, hwc_display_contents_1_t* list)
 {
     size_t i;
     int32_t compositionType = HWC_FRAMEBUFFER;
@@ -782,7 +781,7 @@ void populate_cached_layer_locked(struct hwcomposer_context *ctx, hwc_layer_list
 
     /* lets poplulate the list and and return false since we need a new reference composition done */
     for (i = 0; i < list->numHwLayers; i++) {
-        struct hwc_layer* layer = &list->hwLayers[i];
+        struct hwc_layer_1* layer = &list->hwLayers[i];
 
         if(layer->compositionType == HWC_OVERLAY)
             compositionType = HWC_OVERLAY;
@@ -800,7 +799,7 @@ void populate_cached_layer_locked(struct hwcomposer_context *ctx, hwc_layer_list
     }
 }
 
-bool check_cached_layers_locked(struct hwcomposer_context *ctx, hwc_layer_list_t* list)
+bool check_cached_layers_locked(struct hwcomposer_context *ctx, hwc_display_contents_1_t* list)
 {
     size_t i;
     int32_t compositionType = HWC_FRAMEBUFFER;
@@ -830,7 +829,7 @@ bool check_cached_layers_locked(struct hwcomposer_context *ctx, hwc_layer_list_t
          * change, but order must be preserved */
         bool is_ok = true;
         for (i = 0; i < list->numHwLayers; i++) {
-            struct hwc_layer* layer = &list->hwLayers[i];
+            struct hwc_layer_1* layer = &list->hwLayers[i];
             if (layer->handle != NULL && !(layer->flags & HWC_SKIP_LAYER)) {
                 ALOGI_IF(DEBUG_STE_HWCOMPOSER, "iteration %d", i);
 
@@ -879,7 +878,7 @@ bool check_cached_layers_locked(struct hwcomposer_context *ctx, hwc_layer_list_t
 }
 
 
-int grab_all_layers_locked(struct hwcomposer_context *ctx, hwc_layer_list_t* list)
+int grab_all_layers_locked(struct hwcomposer_context *ctx, hwc_display_contents_1_t* list)
 {
     size_t i;
 
@@ -903,7 +902,7 @@ int grab_all_layers_locked(struct hwcomposer_context *ctx, hwc_layer_list_t* lis
     }
 
     for (i = 0; i < list->numHwLayers; i++) {
-        struct hwc_layer* layer = &list->hwLayers[i];
+        struct hwc_layer_1* layer = &list->hwLayers[i];
 
         ctx->actual_composition_types[i] = layer->compositionType;
         layer->compositionType = HWC_OVERLAY;
@@ -913,14 +912,14 @@ int grab_all_layers_locked(struct hwcomposer_context *ctx, hwc_layer_list_t* lis
     return 0;
 }
 
-void ungrab_fb_layers_locked(struct hwcomposer_context *ctx, hwc_layer_list_t* list)
+void ungrab_fb_layers_locked(struct hwcomposer_context *ctx, hwc_display_contents_1_t* list)
 {
     size_t i;
 
     ALOGI_IF(DEBUG_STE_HWCOMPOSER, "%s", __func__);
 
     for (i = 0; i < list->numHwLayers; i++) {
-        struct hwc_layer* layer = &list->hwLayers[i];
+        struct hwc_layer_1* layer = &list->hwLayers[i];
             ALOGI_IF(DEBUG_STE_HWCOMPOSER,
             "HWC composition layer restored to composition type %d for handle %d",
             ctx->actual_composition_types[i], (int)layer->handle);
@@ -928,13 +927,19 @@ void ungrab_fb_layers_locked(struct hwcomposer_context *ctx, hwc_layer_list_t* l
     }
 }
 
-static int hwcomposer_prepare(struct hwc_composer_device *dev, hwc_layer_list_t* list)
+static int hwcomposer_prepare(hwc_composer_device_1_t *dev, size_t numDisplays, hwc_display_contents_1_t** displays)
 {
     ALOGI_IF(DEBUG_STE_HWCOMPOSER, "%s", __func__);
     struct hwcomposer_context *ctx = (struct hwcomposer_context *)dev;
     size_t i;
     int ret = 0;
 
+    // Compat
+    hwc_display_contents_1_t* list = NULL;
+    if (numDisplays > 0) {
+        list = displays[0];
+    }      
+
     pthread_mutex_lock(&ctx->hwc_mutex);
     ctx->bypass_ovly = false;
 
@@ -942,7 +947,7 @@ static int hwcomposer_prepare(struct hwc_composer_device *dev, hwc_layer_list_t*
         bool skip_layer_scene = false;
         /* Check for skip layer in the bottom layer */
         for (i = 0; i < list->numHwLayers; i++) {
-            struct hwc_layer* layer = &list->hwLayers[i];
+            struct hwc_layer_1* layer = &list->hwLayers[i];
             if (layer->flags & HWC_SKIP_LAYER) {
                 skip_layer_scene = true;
                 break;
@@ -953,7 +958,7 @@ static int hwcomposer_prepare(struct hwc_composer_device *dev, hwc_layer_list_t*
             /* Find out if there is a video layer */
             ctx->videoplayback = false;
             for (i = 0; i < list->numHwLayers; i++) {
-                struct hwc_layer* layer = &list->hwLayers[i];
+                struct hwc_layer_1* layer = &list->hwLayers[i];
                 if (layer->handle != NULL &&
                         bufferIsHWMEM(ctx->gralloc, layer->handle) &&
                         bufferIsYUV(ctx->gralloc, layer->handle)) {
@@ -1008,7 +1013,7 @@ static int hwcomposer_prepare(struct hwc_composer_device *dev, hwc_layer_list_t*
              * General: All B2R2 work will be done inside the kernel in compdev.
              */
             for (i = 0; i < list->numHwLayers; i++) {
-                struct hwc_layer* layer = &list->hwLayers[i];
+                struct hwc_layer_1* layer = &list->hwLayers[i];
 
                 /* The initial state should always be HWC_FRAMEBUFFER */
                 layer->compositionType = HWC_FRAMEBUFFER;
@@ -1175,10 +1180,7 @@ static int hwcomposer_prepare(struct hwc_composer_device *dev, hwc_layer_list_t*
     return ret;
 }
 
-static int hwcomposer_set(struct hwc_composer_device *dev,
-                hwc_display_t dpy,
-                hwc_surface_t sur,
-                hwc_layer_list_t* list)
+static int hwcomposer_set(struct hwc_composer_device_1 *dev, size_t numDisplays, hwc_display_contents_1_t** displays)
 {
     ALOGI_IF(DEBUG_STE_HWCOMPOSER, "%s", __func__);
     struct hwcomposer_context *ctx = (struct hwcomposer_context *)dev;
@@ -1192,6 +1194,11 @@ static int hwcomposer_set(struct hwc_composer_device *dev,
     enum compdev_transform fb_transform;
     enum compdev_transform hw_transform;
 
+    // Only support one display
+    hwc_display_t dpy = displays[0]->dpy;
+    hwc_surface_t sur = displays[0]->sur;
+    hwc_display_contents_1_t* list = displays[0];
+
     /* Clear framerect for calculating visible area */
     memset(&frame_rect, 0, sizeof(frame_rect));
     frame_rect.top = frame_rect.left = INT_MAX;
@@ -1221,7 +1228,7 @@ static int hwcomposer_set(struct hwc_composer_device *dev,
 
         /* 1. Figure out how many layers to send to compdev and the combined size */
         for (i = 0; i < list->numHwLayers; i++) {
-            struct hwc_layer* layer = &list->hwLayers[i];
+            struct hwc_layer_1* layer = &list->hwLayers[i];
 
             if (layer->compositionType == HWC_FRAMEBUFFER) {
                 break;
@@ -1312,13 +1319,14 @@ static int hwcomposer_set(struct hwc_composer_device *dev,
     /* 6. This step is handled by libCompose */
 
     pthread_mutex_unlock(&ctx->hwc_mutex);
+
     return 0;
 error:
     pthread_mutex_unlock(&ctx->hwc_mutex);
     return ret;
 }
 
-void hwcomposer_dump(struct hwc_composer_device* dev, char *buff, int buff_len)
+void hwcomposer_dump(struct hwc_composer_device_1* dev, char *buff, int buff_len)
 {
     ALOGI_IF(DEBUG_STE_HWCOMPOSER, "%s", __func__);
     struct hwcomposer_context *ctx = (struct hwcomposer_context *)dev;
@@ -1327,7 +1335,7 @@ void hwcomposer_dump(struct hwc_composer_device* dev, char *buff, int buff_len)
     pthread_mutex_unlock(&ctx->hwc_mutex);
 }
 
-static int hwcomposer_setparameter(struct hwc_composer_device *dev,
+static int hwcomposer_setparameter(struct hwc_composer_device_1 *dev,
                 int param, int value)
 {
     struct hwcomposer_context *ctx = (struct hwcomposer_context *)dev;
@@ -1362,7 +1370,7 @@ static int hwcomposer_setparameter(struct hwc_composer_device *dev,
     return ret;
 }
 
-static void hwcomposer_register_procs(struct hwc_composer_device* dev, hwc_procs_t const* procs)
+static void hwcomposer_register_procs(struct hwc_composer_device_1* dev, hwc_procs_t const* procs)
 {
     struct hwcomposer_context *ctx = (struct hwcomposer_context *)dev;
     ctx->procs = (struct hwc_procs *)procs;
@@ -1370,7 +1378,7 @@ static void hwcomposer_register_procs(struct hwc_composer_device* dev, hwc_procs
     ALOGI_IF(DEBUG_STE_HWCOMPOSER && !procs, "%s: procs deregistered", __func__);
 }
 
-static int hwcomposer_query(struct hwc_composer_device* dev, int what, int* value)
+static int hwcomposer_query(struct hwc_composer_device_1* dev, int what, int* value)
 {
     struct hwcomposer_context *ctx = (struct hwcomposer_context *)dev;
 
@@ -1398,35 +1406,33 @@ static int hwcomposer_query(struct hwc_composer_device* dev, int what, int* valu
     return 0;
 }
 
-static int hwcomposer_eventControl(struct hwc_composer_device* dev, int event, int enabled)
+static int hwcomposer_eventControl(struct hwc_composer_device_1* dev, int event, int dpy, int enabled)
 {
     struct hwcomposer_context *ctx = (struct hwcomposer_context *)dev;
+    int ret = 0;
 
-    switch (event) {
-        case HWC_EVENT_VSYNC:
-        {
-            //int val = !!enabled;
-            int err;
-
-            //if (hwc_dev->use_sw_vsync) {
-            if (1) {
-                if (enabled)
-                    vsync_monitor_enable();
-                    //start_sw_vsync(hwc_dev);
-                else
-                    vsync_monitor_disable();
-                    //stop_sw_vsync();
-                return 0;
-             }
-
-             /* we never reach here */
-             return 0;
-         }
+    if (enabled != 0 && enabled != 1)
+        return -EINVAL;
 
-        default:
-            return -EINVAL;
-     }
+    switch (event) {
+    case HWC_EVENT_VSYNC:
+    {
+        if (enabled) {
+            if (ctx->procs && ctx->procs->vsync) {
+                vsync_monitor_enable(ctx->procs);
+            } else {
+                ALOGW("%s: Enable VSYNC called without a registered callback", __func__);
+            }
+        } else {
+            vsync_monitor_disable();
+        }
+    }
+    break;
+    default:
+        ALOGW("%s: got unknown event id: %d", __func__, event);
+    }
 
+    return ret;
 }
 
 static enum compdev_transform get_dst_transform(uint32_t hw_rot, enum compdev_transform img_transform)
@@ -1458,7 +1464,7 @@ static void worker_send_compdev_layer(struct worker_context* wctx)
     /* Direct composition */
     ALOGI_IF(DEBUG_STE_HWCOMPOSER, "%s: Direct composition", __func__);
 
-    struct hwc_layer* layer = &wctx->work_list->hwLayers[0];
+    struct hwc_layer_1* layer = &wctx->work_list->hwLayers[0];
 
     if (convert_image(wctx->gralloc, layer->handle, &img))
         ALOGE("%s: Convert image failed", __func__);
@@ -1607,7 +1613,7 @@ static int worker_destroy(struct hwcomposer_context *ctx)
 }
 
 static int worker_signal_update(struct hwcomposer_context *ctx,
-                                hwc_layer_list_t* work_list,
+                                hwc_display_contents_1_t* work_list,
                                 uint32_t compdev_layer_count,
                                 uint32_t compdev_bypass_count,
                                 struct hwc_rect* frame_rect)
@@ -1688,7 +1694,7 @@ static int hwcomposer_device_open(const struct hw_module_t *module,
         pthread_mutex_lock(&ctx->hwc_mutex);
 
         ctx->dev.common.tag = HARDWARE_DEVICE_TAG;
-        ctx->dev.common.version = STE_HWC_DEVICE_API_CURRENT;
+        ctx->dev.common.version = HWC_DEVICE_API_VERSION_1_0;
         ctx->dev.common.module = (struct hw_module_t *)module;
         ctx->dev.common.close = hwcomposer_close;
 
@@ -1697,7 +1703,8 @@ static int hwcomposer_device_open(const struct hw_module_t *module,
         ctx->dev.dump          = hwcomposer_dump;
         ctx->dev.registerProcs = hwcomposer_register_procs;
         ctx->dev.query         = hwcomposer_query;
-        ctx->dev.methods       = &hwcomposer_methods;
+        ctx->dev.blank         = hwcomposer_blank;
+        ctx->dev.eventControl  = hwcomposer_eventControl;
 
         ctx->hwmem = open(HWMEM_PATH, O_RDWR);
         if (ctx->hwmem < 0) {
@@ -1732,15 +1739,7 @@ static int hwcomposer_device_open(const struct hw_module_t *module,
             ALOGE("Error initializing egl worker");
             goto worker_error;
         }
-
-        vsync_monitor_init(ctx);
-
-#ifdef ENABLE_HDMI
-        ctx->hdmi_settings.hdmid_sockfd = open_hdmid_socket();
-        if (ctx->hdmi_settings.hdmid_sockfd < 0)
-            ALOGE("Failed to open communication channel to hdmid");
-#endif
-
+	vsync_monitor_init(ctx);
         *device = &ctx->dev.common;
         pthread_mutex_unlock(&ctx->hwc_mutex);
     } else
@@ -1759,3 +1758,4 @@ static int hwcomposer_device_open(const struct hw_module_t *module,
     return -1;
 }
 
+
diff --git a/display/libhwcomposer/hwcomposer.h b/display/libhwcomposer/hwcomposer.h
index c26b865f..76581080 100644
--- a/display/libhwcomposer/hwcomposer.h
+++ b/display/libhwcomposer/hwcomposer.h
@@ -18,23 +18,26 @@
 #define ANDROID_INCLUDE_HARDWARE_HWCOMPOSER_H
 
 #include <stdint.h>
+#include <stdlib.h>
 #include <sys/cdefs.h>
 
 #include <hardware/gralloc.h>
 #include <hardware/hardware.h>
 #include <cutils/native_handle.h>
 
-#include "hwcomposer_defs.h"
+#include <hardware/hwcomposer_defs.h>
 
 __BEGIN_DECLS
 
 /*****************************************************************************/
 
-// for compatibility
+/* for compatibility */
 #define HWC_MODULE_API_VERSION      HWC_MODULE_API_VERSION_0_1
 #define HWC_DEVICE_API_VERSION      HWC_DEVICE_API_VERSION_0_1
 #define HWC_API_VERSION             HWC_DEVICE_API_VERSION
 
+/*****************************************************************************/
+
 /**
  * The id of this module
  */
@@ -45,56 +48,6 @@ __BEGIN_DECLS
  */
 #define HWC_HARDWARE_COMPOSER   "composer"
 
-
-struct hwc_composer_device;
-
-/*
- * availability: HWC_DEVICE_API_VERSION_0_3
- *
- * struct hwc_methods cannot be embedded in other structures as
- * sizeof(struct hwc_methods) cannot be relied upon.
- *
- */
-typedef struct hwc_methods {
-
-    /*************************************************************************
-     * HWC_DEVICE_API_VERSION_0_3
-     *************************************************************************/
-
-    /*
-     * eventControl(..., event, enabled)
-     * Enables or disables h/w composer events.
-     *
-     * eventControl can be called from any thread and takes effect
-     * immediately.
-     *
-     *  Supported events are:
-     *      HWC_EVENT_VSYNC
-     *
-     * returns -EINVAL if the "event" parameter is not one of the value above
-     * or if the "enabled" parameter is not 0 or 1.
-     */
-
-    int (*eventControl)(
-            struct hwc_composer_device* dev, int event, int enabled);
-
-
-    /*************************************************************************
-     * HWC_DEVICE_API_VERSION_0_3_STE
-     *************************************************************************/
-
-    /*
-     * This hook is vendor specific and optional.
-     *
-     * (*setParameter)() makes the hardware composer aware of the system state,
-     * e.g. hdmi plug status and ui rotation, so that it can make intelligent
-     * decisions on how to handle composed surfaces and cloning in the kernel.
-     */
-    int (*setParameter)(struct hwc_composer_device* dev,
-                int param, int value);
-
-} hwc_methods_t;
-
 typedef struct hwc_rect {
     int left;
     int top;
@@ -102,6 +55,13 @@ typedef struct hwc_rect {
     int bottom;
 } hwc_rect_t;
 
+typedef struct hwc_frect {
+    float left;
+    float top;
+    float right;
+    float bottom;
+} hwc_frect_t;
+
 typedef struct hwc_region {
     size_t numRects;
     hwc_rect_t const* rects;
@@ -114,29 +74,94 @@ typedef struct hwc_color {
     uint8_t a;
 } hwc_color_t;
 
-typedef struct hwc_layer {
+typedef struct hwc_layer_1 {
     /*
-     * initially set to HWC_FRAMEBUFFER or HWC_BACKGROUND.
-     * HWC_FRAMEBUFFER
-     *   indicates the layer will be drawn into the framebuffer
-     *   using OpenGL ES.
-     *   The HWC can toggle this value to HWC_OVERLAY, to indicate
-     *   it will handle the layer.
+     * compositionType is used to specify this layer's type and is set by either
+     * the hardware composer implementation, or by the caller (see below).
+     *
+     *  This field is always reset to HWC_BACKGROUND or HWC_FRAMEBUFFER
+     *  before (*prepare)() is called when the HWC_GEOMETRY_CHANGED flag is
+     *  also set, otherwise, this field is preserved between (*prepare)()
+     *  calls.
      *
      * HWC_BACKGROUND
-     *   indicates this is a special "background"  layer. The only valid
-     *   field is backgroundColor. HWC_BACKGROUND can only be used with
-     *   HWC_API_VERSION >= 0.2
-     *   The HWC can toggle this value to HWC_FRAMEBUFFER, to indicate
-     *   it CANNOT handle the background color
+     *   Always set by the caller before calling (*prepare)(), this value
+     *   indicates this is a special "background" layer. The only valid field
+     *   is backgroundColor.
+     *   The HWC can toggle this value to HWC_FRAMEBUFFER to indicate it CANNOT
+     *   handle the background color.
+     *
+     *
+     * HWC_FRAMEBUFFER_TARGET
+     *   Always set by the caller before calling (*prepare)(), this value
+     *   indicates this layer is the framebuffer surface used as the target of
+     *   OpenGL ES composition. If the HWC sets all other layers to HWC_OVERLAY
+     *   or HWC_BACKGROUND, then no OpenGL ES composition will be done, and
+     *   this layer should be ignored during set().
+     *
+     *   This flag (and the framebuffer surface layer) will only be used if the
+     *   HWC version is HWC_DEVICE_API_VERSION_1_1 or higher. In older versions,
+     *   the OpenGL ES target surface is communicated by the (dpy, sur) fields
+     *   in hwc_compositor_device_1_t.
+     *
+     *   This value cannot be set by the HWC implementation.
+     *
+     *
+     * HWC_FRAMEBUFFER
+     *   Set by the caller before calling (*prepare)() ONLY when the
+     *   HWC_GEOMETRY_CHANGED flag is also set.
+     *
+     *   Set by the HWC implementation during (*prepare)(), this indicates
+     *   that the layer will be drawn into the framebuffer using OpenGL ES.
+     *   The HWC can toggle this value to HWC_OVERLAY to indicate it will
+     *   handle the layer.
+     *
      *
+     * HWC_OVERLAY
+     *   Set by the HWC implementation during (*prepare)(), this indicates
+     *   that the layer will be handled by the HWC (ie: it must not be
+     *   composited with OpenGL ES).
+     *
+     *
+     * HWC_SIDEBAND
+     *   Set by the caller before calling (*prepare)(), this value indicates
+     *   the contents of this layer come from a sideband video stream.
+     *
+     *   The h/w composer is responsible for receiving new image buffers from
+     *   the stream at the appropriate time (e.g. synchronized to a separate
+     *   audio stream), compositing them with the current contents of other
+     *   layers, and displaying the resulting image. This happens
+     *   independently of the normal prepare/set cycle. The prepare/set calls
+     *   only happen when other layers change, or when properties of the
+     *   sideband layer such as position or size change.
+     *
+     *   If the h/w composer can't handle the layer as a sideband stream for
+     *   some reason (e.g. unsupported scaling/blending/rotation, or too many
+     *   sideband layers) it can set compositionType to HWC_FRAMEBUFFER in
+     *   (*prepare)(). However, doing so will result in the layer being shown
+     *   as a solid color since the platform is not currently able to composite
+     *   sideband layers with the GPU. This may be improved in future
+     *   versions of the platform.
+     *
+     *
+     * HWC_CURSOR_OVERLAY
+     *   Set by the HWC implementation during (*prepare)(), this value
+     *   indicates the layer's composition will now be handled by the HWC.
+     *   Additionally, the client can now asynchronously update the on-screen
+     *   position of this layer using the setCursorPositionAsync() api.
      */
     int32_t compositionType;
 
-    /* see hwc_layer_t::hints above */
+    /*
+     * hints is bit mask set by the HWC implementation during (*prepare)().
+     * It is preserved between (*prepare)() calls, unless the
+     * HWC_GEOMETRY_CHANGED flag is set, in which case it is reset to 0.
+     *
+     * see hwc_layer_t::hints
+     */
     uint32_t hints;
 
-    /* see hwc_layer_t::flags above */
+    /* see hwc_layer_t::flags */
     uint32_t flags;
 
     union {
@@ -144,13 +169,21 @@ typedef struct hwc_layer {
         hwc_color_t backgroundColor;
 
         struct {
-            /* handle of buffer to compose. This handle is guaranteed to have been
-             * allocated from gralloc using the GRALLOC_USAGE_HW_COMPOSER usage flag. If
-             * the layer's handle is unchanged across two consecutive prepare calls and
-             * the HWC_GEOMETRY_CHANGED flag is not set for the second call then the
-             * HWComposer implementation may assume that the contents of the buffer have
-             * not changed. */
-            buffer_handle_t handle;
+            union {
+                /* When compositionType is HWC_FRAMEBUFFER, HWC_OVERLAY,
+                 * HWC_FRAMEBUFFER_TARGET, this is the handle of the buffer to
+                 * compose. This handle is guaranteed to have been allocated
+                 * from gralloc using the GRALLOC_USAGE_HW_COMPOSER usage flag.
+                 * If the layer's handle is unchanged across two consecutive
+                 * prepare calls and the HWC_GEOMETRY_CHANGED flag is not set
+                 * for the second call then the HWComposer implementation may
+                 * assume that the contents of the buffer have not changed. */
+                buffer_handle_t handle;
+
+                /* When compositionType is HWC_SIDEBAND, this is the handle
+                 * of the sideband video stream to compose. */
+                const native_handle_t* sidebandStream;
+            };
 
             /* transformation to apply to the buffer during composition */
             uint32_t transform;
@@ -159,8 +192,17 @@ typedef struct hwc_layer {
             int32_t blending;
 
             /* area of the source to consider, the origin is the top-left corner of
-             * the buffer */
-            hwc_rect_t sourceCrop;
+             * the buffer. As of HWC_DEVICE_API_VERSION_1_3, sourceRect uses floats.
+             * If the h/w can't support a non-integer source crop rectangle, it should
+             * punt to OpenGL ES composition.
+             */
+            union {
+                // crop rectangle in integer (pre HWC_DEVICE_API_VERSION_1_3)
+                hwc_rect_t sourceCropi;
+                hwc_rect_t sourceCrop; // just for source compatibility
+                // crop rectangle in floats (as of HWC_DEVICE_API_VERSION_1_3)
+                hwc_frect_t sourceCropf;
+            };
 
             /* where to composite the sourceCrop onto the display. The sourceCrop
              * is scaled using linear filtering to the displayFrame. The origin is the
@@ -173,42 +215,237 @@ typedef struct hwc_layer {
              * The visible region INCLUDES areas overlapped by a translucent layer.
              */
             hwc_region_t visibleRegionScreen;
+
+            /* Sync fence object that will be signaled when the buffer's
+             * contents are available. May be -1 if the contents are already
+             * available. This field is only valid during set(), and should be
+             * ignored during prepare(). The set() call must not wait for the
+             * fence to be signaled before returning, but the HWC must wait for
+             * all buffers to be signaled before reading from them.
+             *
+             * HWC_FRAMEBUFFER layers will never have an acquire fence, since
+             * reads from them are complete before the framebuffer is ready for
+             * display.
+             *
+             * HWC_SIDEBAND layers will never have an acquire fence, since
+             * synchronization is handled through implementation-defined
+             * sideband mechanisms.
+             *
+             * The HWC takes ownership of the acquireFenceFd and is responsible
+             * for closing it when no longer needed.
+             */
+            int acquireFenceFd;
+
+            /* During set() the HWC must set this field to a file descriptor for
+             * a sync fence object that will signal after the HWC has finished
+             * reading from the buffer. The field is ignored by prepare(). Each
+             * layer should have a unique file descriptor, even if more than one
+             * refer to the same underlying fence object; this allows each to be
+             * closed independently.
+             *
+             * If buffer reads can complete at significantly different times,
+             * then using independent fences is preferred. For example, if the
+             * HWC handles some layers with a blit engine and others with
+             * overlays, then the blit layers can be reused immediately after
+             * the blit completes, but the overlay layers can't be reused until
+             * a subsequent frame has been displayed.
+             *
+             * Since HWC doesn't read from HWC_FRAMEBUFFER layers, it shouldn't
+             * produce a release fence for them. The releaseFenceFd will be -1
+             * for these layers when set() is called.
+             *
+             * Since HWC_SIDEBAND buffers don't pass through the HWC client,
+             * the HWC shouldn't produce a release fence for them. The
+             * releaseFenceFd will be -1 for these layers when set() is called.
+             *
+             * The HWC client taks ownership of the releaseFenceFd and is
+             * responsible for closing it when no longer needed.
+             */
+            int releaseFenceFd;
+
+            /*
+             * Availability: HWC_DEVICE_API_VERSION_1_2
+             *
+             * Alpha value applied to the whole layer. The effective
+             * value of each pixel is computed as:
+             *
+             *   if (blending == HWC_BLENDING_PREMULT)
+             *      pixel.rgb = pixel.rgb * planeAlpha / 255
+             *   pixel.a = pixel.a * planeAlpha / 255
+             *
+             * Then blending proceeds as usual according to the "blending"
+             * field above.
+             *
+             * NOTE: planeAlpha applies to YUV layers as well:
+             *
+             *   pixel.rgb = yuv_to_rgb(pixel.yuv)
+             *   if (blending == HWC_BLENDING_PREMULT)
+             *      pixel.rgb = pixel.rgb * planeAlpha / 255
+             *   pixel.a = planeAlpha
+             *
+             *
+             * IMPLEMENTATION NOTE:
+             *
+             * If the source image doesn't have an alpha channel, then
+             * the h/w can use the HWC_BLENDING_COVERAGE equations instead of
+             * HWC_BLENDING_PREMULT and simply set the alpha channel to
+             * planeAlpha.
+             *
+             * e.g.:
+             *
+             *   if (blending == HWC_BLENDING_PREMULT)
+             *      blending = HWC_BLENDING_COVERAGE;
+             *   pixel.a = planeAlpha;
+             *
+             */
+            uint8_t planeAlpha;
+
+            /* Pad to 32 bits */
+            uint8_t _pad[3];
+
+            /*
+             * Availability: HWC_DEVICE_API_VERSION_1_5
+             *
+             * This defines the region of the source buffer that has been
+             * modified since the last frame.
+             *
+             * If surfaceDamage.numRects > 0, then it may be assumed that any
+             * portion of the source buffer not covered by one of the rects has
+             * not been modified this frame. If surfaceDamage.numRects == 0,
+             * then the whole source buffer must be treated as if it had been
+             * modified.
+             *
+             * If the layer's contents are not modified relative to the prior
+             * prepare/set cycle, surfaceDamage will contain exactly one empty
+             * rect ([0, 0, 0, 0]).
+             *
+             * The damage rects are relative to the pre-transformed buffer, and
+             * their origin is the top-left corner.
+             */
+            hwc_region_t surfaceDamage;
         };
     };
-} hwc_layer_t;
 
+#ifdef __LP64__
+    /*
+     * For 64-bit mode, this struct is 120 bytes (and 8-byte aligned), and needs
+     * to be padded as such to maintain binary compatibility.
+     */
+    uint8_t reserved[120 - 112];
+#else
+    /*
+     * For 32-bit mode, this struct is 96 bytes, and needs to be padded as such
+     * to maintain binary compatibility.
+     */
+    uint8_t reserved[96 - 84];
+#endif
+
+} hwc_layer_1_t;
+
+/* This represents a display, typically an EGLDisplay object */
+typedef void* hwc_display_t;
+
+/* This represents a surface, typically an EGLSurface object  */
+typedef void* hwc_surface_t;
 
 /*
- * hwc_layer_list_t::flags values
+ * hwc_display_contents_1_t::flags values
  */
 enum {
     /*
      * HWC_GEOMETRY_CHANGED is set by SurfaceFlinger to indicate that the list
-     * passed to (*prepare)() has changed by more than just the buffer handles.
+     * passed to (*prepare)() has changed by more than just the buffer handles
+     * and acquire fences.
      */
     HWC_GEOMETRY_CHANGED = 0x00000001,
 };
 
 /*
- * List of layers.
- * The handle members of hwLayers elements must be unique.
+ * Description of the contents to output on a display.
+ *
+ * This is the top-level structure passed to the prepare and set calls to
+ * negotiate and commit the composition of a display image.
  */
-typedef struct hwc_layer_list {
-    uint32_t flags;
-    size_t numHwLayers;
-    hwc_layer_t hwLayers[0];
-} hwc_layer_list_t;
+typedef struct hwc_display_contents_1 {
+    /* File descriptor referring to a Sync HAL fence object which will signal
+     * when this composition is retired. For a physical display, a composition
+     * is retired when it has been replaced on-screen by a subsequent set. For
+     * a virtual display, the composition is retired when the writes to
+     * outputBuffer are complete and can be read. The fence object is created
+     * and returned by the set call; this field will be -1 on entry to prepare
+     * and set. SurfaceFlinger will close the returned file descriptor.
+     */
+    int retireFenceFd;
 
-/* This represents a display, typically an EGLDisplay object */
-typedef void* hwc_display_t;
+    union {
+        /* Fields only relevant for HWC_DEVICE_VERSION_1_0. */
+        struct {
+            /* (dpy, sur) is the target of SurfaceFlinger's OpenGL ES
+             * composition for HWC_DEVICE_VERSION_1_0. They aren't relevant to
+             * prepare. The set call should commit this surface atomically to
+             * the display along with any overlay layers.
+             */
+            hwc_display_t dpy;
+            hwc_surface_t sur;
+        };
 
-/* This represents a surface, typically an EGLSurface object  */
-typedef void* hwc_surface_t;
+        /* These fields are used for virtual displays when the h/w composer
+         * version is at least HWC_DEVICE_VERSION_1_3. */
+        struct {
+            /* outbuf is the buffer that receives the composed image for
+             * virtual displays. Writes to the outbuf must wait until
+             * outbufAcquireFenceFd signals. A fence that will signal when
+             * writes to outbuf are complete should be returned in
+             * retireFenceFd.
+             *
+             * This field is set before prepare(), so properties of the buffer
+             * can be used to decide which layers can be handled by h/w
+             * composer.
+             *
+             * If prepare() sets all layers to FRAMEBUFFER, then GLES
+             * composition will happen directly to the output buffer. In this
+             * case, both outbuf and the FRAMEBUFFER_TARGET layer's buffer will
+             * be the same, and set() has no work to do besides managing fences.
+             *
+             * If the TARGET_FORCE_HWC_FOR_VIRTUAL_DISPLAYS board config
+             * variable is defined (not the default), then this behavior is
+             * changed: if all layers are marked for FRAMEBUFFER, GLES
+             * composition will take place to a scratch framebuffer, and
+             * h/w composer must copy it to the output buffer. This allows the
+             * h/w composer to do format conversion if there are cases where
+             * that is more desirable than doing it in the GLES driver or at the
+             * virtual display consumer.
+             *
+             * If some or all layers are marked OVERLAY, then the framebuffer
+             * and output buffer will be different. As with physical displays,
+             * the framebuffer handle will not change between frames if all
+             * layers are marked for OVERLAY.
+             */
+            buffer_handle_t outbuf;
+
+            /* File descriptor for a fence that will signal when outbuf is
+             * ready to be written. The h/w composer is responsible for closing
+             * this when no longer needed.
+             *
+             * Will be -1 whenever outbuf is NULL, or when the outbuf can be
+             * written immediately.
+             */
+            int outbufAcquireFenceFd;
+        };
+    };
+
+    /* List of layers that will be composed on the display. The buffer handles
+     * in the list will be unique. If numHwLayers is 0, all composition will be
+     * performed by SurfaceFlinger.
+     */
+    uint32_t flags;
+    size_t numHwLayers;
+    hwc_layer_1_t hwLayers[0];
 
+} hwc_display_contents_1_t;
 
 /* see hwc_composer_device::registerProcs()
- * Any of the callbacks can be NULL, in which case the corresponding
- * functionality is not supported.
+ * All of the callbacks are required and non-NULL unless otherwise noted.
  */
 typedef struct hwc_procs {
     /*
@@ -220,13 +457,14 @@ typedef struct hwc_procs {
      * it is safe to call invalidate() from any of hwc_composer_device
      * hooks, unless noted otherwise.
      */
-    void (*invalidate)(struct hwc_procs* procs);
+    void (*invalidate)(const struct hwc_procs* procs);
 
     /*
      * (*vsync)() is called by the h/w composer HAL when a vsync event is
-     * received and HWC_EVENT_VSYNC is enabled (see: hwc_event_control).
+     * received and HWC_EVENT_VSYNC is enabled on a display
+     * (see: hwc_event_control).
      *
-     * the "zero" parameter must always be 0.
+     * the "disp" parameter indicates which display the vsync event is for.
      * the "timestamp" parameter is the system monotonic clock timestamp in
      *   nanosecond of when the vsync event happened.
      *
@@ -240,31 +478,53 @@ typedef struct hwc_procs {
      * hwc_composer_device.set(..., 0, 0, 0) (screen off). The implementation
      * can either stop or continue to process VSYNC events, but must not
      * crash or cause other problems.
+     */
+    void (*vsync)(const struct hwc_procs* procs, int disp, int64_t timestamp);
+
+    /*
+     * (*hotplug)() is called by the h/w composer HAL when a display is
+     * connected or disconnected. The PRIMARY display is always connected and
+     * the hotplug callback should not be called for it.
+     *
+     * The disp parameter indicates which display type this event is for.
+     * The connected parameter indicates whether the display has just been
+     *   connected (1) or disconnected (0).
+     *
+     * The hotplug() callback may call back into the h/w composer on the same
+     * thread to query refresh rate and dpi for the display. Additionally,
+     * other threads may be calling into the h/w composer while the callback
+     * is in progress.
+     *
+     * The h/w composer must serialize calls to the hotplug callback; only
+     * one thread may call it at a time.
      *
+     * This callback will be NULL if the h/w composer is using
+     * HWC_DEVICE_API_VERSION_1_0.
      */
-    void (*vsync)(struct hwc_procs* procs, int zero, int64_t timestamp);
+    void (*hotplug)(const struct hwc_procs* procs, int disp, int connected);
+
 } hwc_procs_t;
 
 
 /*****************************************************************************/
 
 typedef struct hwc_module {
+    /**
+     * Common methods of the hardware composer module.  This *must* be the first member of
+     * hwc_module as users of this structure will cast a hw_module_t to
+     * hwc_module pointer in contexts where it's known the hw_module_t references a
+     * hwc_module.
+     */
     struct hw_module_t common;
 } hwc_module_t;
 
-/*
- * names for setParameter()
- */
-enum {
-    /* Specifies the UI orientation */
-    HWC_UI_ORIENTATION = 0x00000000,
-    /* Specifies if hardware rotation is used */
-    HWC_HARDWARE_ROTATION = 0x00000001,
-    /* Set the hdmi plug status */
-    HWC_HDMI_PLUGGED = 0x00000002,
-};
-
-typedef struct hwc_composer_device {
+typedef struct hwc_composer_device_1 {
+    /**
+     * Common methods of the hardware composer device.  This *must* be the first member of
+     * hwc_composer_device_1 as users of this structure will cast a hw_device_t to
+     * hwc_composer_device_1 pointer in contexts where it's known the hw_device_t references a
+     * hwc_composer_device_1.
+     */
     struct hw_device_t common;
 
     /*
@@ -273,132 +533,321 @@ typedef struct hwc_composer_device {
      *
      * (*prepare)() can be called more than once, the last call prevails.
      *
-     * The HWC responds by setting the compositionType field to either
-     * HWC_FRAMEBUFFER or HWC_OVERLAY. In the former case, the composition for
-     * this layer is handled by SurfaceFlinger with OpenGL ES, in the later
-     * case, the HWC will have to handle this layer's composition.
+     * The HWC responds by setting the compositionType field in each layer to
+     * either HWC_FRAMEBUFFER, HWC_OVERLAY, or HWC_CURSOR_OVERLAY. For the
+     * HWC_FRAMEBUFFER type, composition for the layer is handled by
+     * SurfaceFlinger with OpenGL ES. For the latter two overlay types,
+     * the HWC will have to handle the layer's composition. compositionType
+     * and hints are preserved between (*prepare)() calles unless the
+     * HWC_GEOMETRY_CHANGED flag is set.
      *
      * (*prepare)() is called with HWC_GEOMETRY_CHANGED to indicate that the
      * list's geometry has changed, that is, when more than just the buffer's
      * handles have been updated. Typically this happens (but is not limited to)
-     * when a window is added, removed, resized or moved.
+     * when a window is added, removed, resized or moved. In this case
+     * compositionType and hints are reset to their default value.
      *
-     * a NULL list parameter or a numHwLayers of zero indicates that the
-     * entire composition will be handled by SurfaceFlinger with OpenGL ES.
+     * For HWC 1.0, numDisplays will always be one, and displays[0] will be
+     * non-NULL.
+     *
+     * For HWC 1.1, numDisplays will always be HWC_NUM_PHYSICAL_DISPLAY_TYPES.
+     * Entries for unsupported or disabled/disconnected display types will be
+     * NULL.
+     *
+     * In HWC 1.3, numDisplays may be up to HWC_NUM_DISPLAY_TYPES. The extra
+     * entries correspond to enabled virtual displays, and will be non-NULL.
      *
      * returns: 0 on success. An negative error code on error. If an error is
      * returned, SurfaceFlinger will assume that none of the layer will be
      * handled by the HWC.
      */
-    int (*prepare)(struct hwc_composer_device *dev, hwc_layer_list_t* list);
-
+    int (*prepare)(struct hwc_composer_device_1 *dev,
+                    size_t numDisplays, hwc_display_contents_1_t** displays);
 
     /*
      * (*set)() is used in place of eglSwapBuffers(), and assumes the same
      * functionality, except it also commits the work list atomically with
      * the actual eglSwapBuffers().
      *
-     * The list parameter is guaranteed to be the same as the one returned
-     * from the last call to (*prepare)().
+     * The layer lists are guaranteed to be the same as the ones returned from
+     * the last call to (*prepare)().
      *
-     * When this call returns the caller assumes that:
+     * When this call returns the caller assumes that the displays will be
+     * updated in the near future with the content of their work lists, without
+     * artifacts during the transition from the previous frame.
      *
-     * - the display will be updated in the near future with the content
-     *   of the work list, without artifacts during the transition from the
-     *   previous frame.
+     * A display with zero layers indicates that the entire composition has
+     * been handled by SurfaceFlinger with OpenGL ES. In this case, (*set)()
+     * behaves just like eglSwapBuffers().
      *
-     * - all objects are available for immediate access or destruction, in
-     *   particular, hwc_region_t::rects data and hwc_layer_t::layer's buffer.
-     *   Note that this means that immediately accessing (potentially from a
-     *   different process) a buffer used in this call will not result in
-     *   screen corruption, the driver must apply proper synchronization or
-     *   scheduling (eg: block the caller, such as gralloc_module_t::lock(),
-     *   OpenGL ES, Camera, Codecs, etc..., or schedule the caller's work
-     *   after the buffer is freed from the actual composition).
+     * For HWC 1.0, numDisplays will always be one, and displays[0] will be
+     * non-NULL.
      *
-     * a NULL list parameter or a numHwLayers of zero indicates that the
-     * entire composition has been handled by SurfaceFlinger with OpenGL ES.
-     * In this case, (*set)() behaves just like eglSwapBuffers().
+     * For HWC 1.1, numDisplays will always be HWC_NUM_PHYSICAL_DISPLAY_TYPES.
+     * Entries for unsupported or disabled/disconnected display types will be
+     * NULL.
      *
-     * dpy, sur, and list are set to NULL to indicate that the screen is
-     * turning off. This happens WITHOUT prepare() being called first.
-     * This is a good time to free h/w resources and/or power
-     * the relevant h/w blocks down.
+     * In HWC 1.3, numDisplays may be up to HWC_NUM_DISPLAY_TYPES. The extra
+     * entries correspond to enabled virtual displays, and will be non-NULL.
      *
-     * IMPORTANT NOTE: there is an implicit layer containing opaque black
-     * pixels behind all the layers in the list.
-     * It is the responsibility of the hwcomposer module to make
-     * sure black pixels are output (or blended from).
+     * IMPORTANT NOTE: There is an implicit layer containing opaque black
+     * pixels behind all the layers in the list. It is the responsibility of
+     * the hwcomposer module to make sure black pixels are output (or blended
+     * from).
      *
-     * returns: 0 on success. An negative error code on error:
-     *    HWC_EGL_ERROR: eglGetError() will provide the proper error code
+     * IMPORTANT NOTE: In the event of an error this call *MUST* still cause
+     * any fences returned in the previous call to set to eventually become
+     * signaled.  The caller may have already issued wait commands on these
+     * fences, and having set return without causing those fences to signal
+     * will likely result in a deadlock.
+     *
+     * returns: 0 on success. A negative error code on error:
+     *    HWC_EGL_ERROR: eglGetError() will provide the proper error code (only
+     *        allowed prior to HWComposer 1.1)
      *    Another code for non EGL errors.
+     */
+    int (*set)(struct hwc_composer_device_1 *dev,
+                size_t numDisplays, hwc_display_contents_1_t** displays);
+
+    /*
+     * eventControl(..., event, enabled)
+     * Enables or disables h/w composer events for a display.
+     *
+     * eventControl can be called from any thread and takes effect
+     * immediately.
+     *
+     *  Supported events are:
+     *      HWC_EVENT_VSYNC
      *
+     * returns -EINVAL if the "event" parameter is not one of the value above
+     * or if the "enabled" parameter is not 0 or 1.
      */
-    int (*set)(struct hwc_composer_device *dev,
-                hwc_display_t dpy,
-                hwc_surface_t sur,
-                hwc_layer_list_t* list);
+    int (*eventControl)(struct hwc_composer_device_1* dev, int disp,
+            int event, int enabled);
+
+    union {
+        /*
+         * For HWC 1.3 and earlier, the blank() interface is used.
+         *
+         * blank(..., blank)
+         * Blanks or unblanks a display's screen.
+         *
+         * Turns the screen off when blank is nonzero, on when blank is zero.
+         * Multiple sequential calls with the same blank value must be
+         * supported.
+         * The screen state transition must be be complete when the function
+         * returns.
+         *
+         * returns 0 on success, negative on error.
+         */
+        int (*blank)(struct hwc_composer_device_1* dev, int disp, int blank);
+
+        /*
+         * For HWC 1.4 and above, setPowerMode() will be used in place of
+         * blank().
+         *
+         * setPowerMode(..., mode)
+         * Sets the display screen's power state.
+         *
+         * Refer to the documentation of the HWC_POWER_MODE_* constants
+         * for information about each power mode.
+         *
+         * The functionality is similar to the blank() command in previous
+         * versions of HWC, but with support for more power states.
+         *
+         * The display driver is expected to retain and restore the low power
+         * state of the display while entering and exiting from suspend.
+         *
+         * Multiple sequential calls with the same mode value must be supported.
+         *
+         * The screen state transition must be be complete when the function
+         * returns.
+         *
+         * returns 0 on success, negative on error.
+         */
+        int (*setPowerMode)(struct hwc_composer_device_1* dev, int disp,
+                int mode);
+    };
+
+    /*
+     * Used to retrieve information about the h/w composer
+     *
+     * Returns 0 on success or -errno on error.
+     */
+    int (*query)(struct hwc_composer_device_1* dev, int what, int* value);
+
+    /*
+     * (*registerProcs)() registers callbacks that the h/w composer HAL can
+     * later use. It will be called immediately after the composer device is
+     * opened with non-NULL procs. It is FORBIDDEN to call any of the callbacks
+     * from within registerProcs(). registerProcs() must save the hwc_procs_t
+     * pointer which is needed when calling a registered callback.
+     */
+    void (*registerProcs)(struct hwc_composer_device_1* dev,
+            hwc_procs_t const* procs);
+
     /*
      * This field is OPTIONAL and can be NULL.
      *
      * If non NULL it will be called by SurfaceFlinger on dumpsys
      */
-    void (*dump)(struct hwc_composer_device* dev, char *buff, int buff_len);
+    void (*dump)(struct hwc_composer_device_1* dev, char *buff, int buff_len);
 
     /*
-     * This field is OPTIONAL and can be NULL.
+     * (*getDisplayConfigs)() returns handles for the configurations available
+     * on the connected display. These handles must remain valid as long as the
+     * display is connected.
+     *
+     * Configuration handles are written to configs. The number of entries
+     * allocated by the caller is passed in *numConfigs; getDisplayConfigs must
+     * not try to write more than this number of config handles. On return, the
+     * total number of configurations available for the display is returned in
+     * *numConfigs. If *numConfigs is zero on entry, then configs may be NULL.
      *
-     * (*registerProcs)() registers a set of callbacks the h/w composer HAL
-     * can later use. It is FORBIDDEN to call any of the callbacks from
-     * within registerProcs(). registerProcs() must save the hwc_procs_t pointer
-     * which is needed when calling a registered callback.
-     * Each call to registerProcs replaces the previous set of callbacks.
-     * registerProcs is called with NULL to unregister all callbacks.
+     * Hardware composers implementing HWC_DEVICE_API_VERSION_1_3 or prior
+     * shall choose one configuration to activate and report it as the first
+     * entry in the returned list. Reporting the inactive configurations is not
+     * required.
      *
-     * Any of the callbacks can be NULL, in which case the corresponding
-     * functionality is not supported.
+     * HWC_DEVICE_API_VERSION_1_4 and later provide configuration management
+     * through SurfaceFlinger, and hardware composers implementing these APIs
+     * must also provide getActiveConfig and setActiveConfig. Hardware composers
+     * implementing these API versions may choose not to activate any
+     * configuration, leaving configuration selection to higher levels of the
+     * framework.
+     *
+     * Returns 0 on success or a negative error code on error. If disp is a
+     * hotpluggable display type and no display is connected, an error shall be
+     * returned.
+     *
+     * This field is REQUIRED for HWC_DEVICE_API_VERSION_1_1 and later.
+     * It shall be NULL for previous versions.
      */
-    void (*registerProcs)(struct hwc_composer_device* dev,
-            hwc_procs_t const* procs);
+    int (*getDisplayConfigs)(struct hwc_composer_device_1* dev, int disp,
+            uint32_t* configs, size_t* numConfigs);
 
     /*
-     * This field is OPTIONAL and can be NULL.
-     * availability: HWC_DEVICE_API_VERSION_0_2
+     * (*getDisplayAttributes)() returns attributes for a specific config of a
+     * connected display. The config parameter is one of the config handles
+     * returned by getDisplayConfigs.
      *
-     * Used to retrieve information about the h/w composer
+     * The list of attributes to return is provided in the attributes
+     * parameter, terminated by HWC_DISPLAY_NO_ATTRIBUTE. The value for each
+     * requested attribute is written in order to the values array. The
+     * HWC_DISPLAY_NO_ATTRIBUTE attribute does not have a value, so the values
+     * array will have one less value than the attributes array.
      *
-     * Returns 0 on success or -errno on error.
+     * This field is REQUIRED for HWC_DEVICE_API_VERSION_1_1 and later.
+     * It shall be NULL for previous versions.
+     *
+     * If disp is a hotpluggable display type and no display is connected,
+     * or if config is not a valid configuration for the display, a negative
+     * error code shall be returned.
+     */
+    int (*getDisplayAttributes)(struct hwc_composer_device_1* dev, int disp,
+            uint32_t config, const uint32_t* attributes, int32_t* values);
+
+    /*
+     * (*getActiveConfig)() returns the index of the configuration that is
+     * currently active on the connected display. The index is relative to
+     * the list of configuration handles returned by getDisplayConfigs. If there
+     * is no active configuration, -1 shall be returned.
+     *
+     * Returns the configuration index on success or -1 on error.
+     *
+     * This field is REQUIRED for HWC_DEVICE_API_VERSION_1_4 and later.
+     * It shall be NULL for previous versions.
+     */
+    int (*getActiveConfig)(struct hwc_composer_device_1* dev, int disp);
+
+    /*
+     * (*setActiveConfig)() instructs the hardware composer to switch to the
+     * display configuration at the given index in the list of configuration
+     * handles returned by getDisplayConfigs.
+     *
+     * If this function returns without error, any subsequent calls to
+     * getActiveConfig shall return the index set by this function until one
+     * of the following occurs:
+     *   1) Another successful call of this function
+     *   2) The display is disconnected
+     *
+     * Returns 0 on success or a negative error code on error. If disp is a
+     * hotpluggable display type and no display is connected, or if index is
+     * outside of the range of hardware configurations returned by
+     * getDisplayConfigs, an error shall be returned.
+     *
+     * This field is REQUIRED for HWC_DEVICE_API_VERSION_1_4 and later.
+     * It shall be NULL for previous versions.
+     */
+    int (*setActiveConfig)(struct hwc_composer_device_1* dev, int disp,
+            int index);
+    /*
+     * Asynchronously update the location of the cursor layer.
+     *
+     * Within the standard prepare()/set() composition loop, the client
+     * (surfaceflinger) can request that a given layer uses dedicated cursor
+     * composition hardware by specifiying the HWC_IS_CURSOR_LAYER flag. Only
+     * one layer per display can have this flag set. If the layer is suitable
+     * for the platform's cursor hardware, hwcomposer will return from prepare()
+     * a composition type of HWC_CURSOR_OVERLAY for that layer. This indicates
+     * not only that the client is not responsible for compositing that layer,
+     * but also that the client can continue to update the position of that layer
+     * after a call to set(). This can reduce the visible latency of mouse
+     * movement to visible, on-screen cursor updates. Calls to
+     * setCursorPositionAsync() may be made from a different thread doing the
+     * prepare()/set() composition loop, but care must be taken to not interleave
+     * calls of setCursorPositionAsync() between calls of set()/prepare().
+     *
+     * Notes:
+     * - Only one layer per display can be specified as a cursor layer with
+     *   HWC_IS_CURSOR_LAYER.
+     * - hwcomposer will only return one layer per display as HWC_CURSOR_OVERLAY
+     * - This returns 0 on success or -errno on error.
+     * - This field is optional for HWC_DEVICE_API_VERSION_1_4 and later. It
+     *   should be null for previous versions.
      */
-    int (*query)(struct hwc_composer_device* dev, int what, int* value);
+    int (*setCursorPositionAsync)(struct hwc_composer_device_1 *dev, int disp, int x_pos, int y_pos);
 
     /*
      * Reserved for future use. Must be NULL.
      */
-    void* reserved_proc[4];
+    void* reserved_proc[1];
 
     /*
-     * This field is OPTIONAL and can be NULL.
-     * availability: HWC_DEVICE_API_VERSION_0_3
+     * This hook is vendor specific and optional.
+     *
+     * (*setParameter)() makes the hardware composer aware of the system state,
+     * e.g. hdmi plug status and ui rotation, so that it can make intelligent
+     * decisions on how to handle composed surfaces and cloning in the kernel.
      */
-    hwc_methods_t const *methods;
+    int (*setParameter)(struct hwc_composer_device_1* dev, int param, int value);
 
-} hwc_composer_device_t;
+/*
+ * names for setParameter()
+ */
+enum {
+    /* Specifies the UI orientation */
+    HWC_UI_ORIENTATION = 0x00000000,
+    /* Specifies if hardware rotation is used */
+    HWC_HARDWARE_ROTATION = 0x00000001,
+    /* Set the hdmi plug status */
+    HWC_HDMI_PLUGGED = 0x00000002,
+};
 
+} hwc_composer_device_1_t;
 
 /** convenience API for opening and closing a device */
 
-static inline int hwc_open(const struct hw_module_t* module,
-        hwc_composer_device_t** device) {
+static inline int hwc_open_1(const struct hw_module_t* module,
+        hwc_composer_device_1_t** device) {
     return module->methods->open(module,
             HWC_HARDWARE_COMPOSER, (struct hw_device_t**)device);
 }
 
-static inline int hwc_close(hwc_composer_device_t* device) {
+static inline int hwc_close_1(hwc_composer_device_1_t* device) {
     return device->common.close(&device->common);
 }
 
-
 /*****************************************************************************/
 
 __END_DECLS

